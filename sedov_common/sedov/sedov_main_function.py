#Main Sedov Code Module#Ported to python from fortran code written by James R Kamm and F X Timmes#Original Paper and code found at http://cococubed.asu.edu/papers/la-ur-07-2849.pdfimport numpy as npfrom globalvars import comvars as gvfrom sedov_1d import sed_1dfrom sedov_1d_time import sed_1d_timefrom sedov_1d_energy_time_gamma import sed_1d_energy_time_gammafrom matplotlib import pyplot as pltimport pickleimport osos.system("mkdir plots")# location = './paper_results_data/plots'gv.its = 20def sedov_var_initial_energy_time_gamma(geom_in, omega_in, energy, time                                        , gamma, outfile,                             position_hi=10, number_steps=44000, rho_0=1.225E0):    ##Explicitly set variables    ##Standard Cases    ##Spherical constant density should reach r=1 at t=1    nstep = number_steps    # eblast = blast_energy    gv.xgeom = geom_in    gv.omega = omega_in    # outputfile = ??????    ##input parameters    rho0 = rho_0    vel0 = 0.0E0    ener0 = 0.0E0    pres0 = 0.0E0    # cs0 = 342.3E0    cs0 = 0    # gv.gamma = gamma_in    ##number of grid points, spatial domain, spatial stepsize.    ##to match hydrocode output, use the mid-sell points.    # zpos = array of spatial points    zlo = 0.0E0    zhi = position_hi    zstep = (zhi - zlo) / float(nstep)    zposition = np.arange(zlo + zstep, zhi + zstep, zstep)    # den_time, vel_time, pres_time, enertot_time, enertherm_time, enerkin_time, mach_time, zpos_time, time,\    # discrete_radius, discrete_velo, discrete_pres, discrete_rho,\    # discrete_energ = sed_1d_time(time_initial, time_final, time_steps, nstep, zposition, eblast, rho0, vel0, ener0, pres0, cs0, gv)    # without mach number    den_time, vel_time, pres_time, enertot_time, enertherm_time, enerkin_time, zpos_time, initial_energy, \    discrete_radius, discrete_velo, discrete_pres, discrete_rho, \    eblast_ , reported_time, gamma= sed_1d_energy_time_gamma(energy, nstep, zposition                                                , time,gamma, rho0, vel0, ener0,pres0,cs0, gv)    # create final dictionary to pickle    ###dictionary is flexible array    # time_step_output = {'density': den_time, 'velocity': vel_time, 'pressure': pres_time,    #    #                       'total_energy': enertot_time, 'thermal_energy': enertherm_time,    #    #                       'kinetic_energy': enerkin_time, 'mach': mach_time,    #    #                       'position': zpos_time, 'time': time, 'disc_r':discrete_radius, 'disc_u': discrete_velo,    #    #                     'disc_p':discrete_pres, 'disc_rho':discrete_rho, 'disc_e':discrete_energ}    # without mach number    time_step_output = {'initial_energy': initial_energy, 'arrival_distance': discrete_radius, 'u_max': discrete_velo,                        'p_max': discrete_pres, 'rho_max': discrete_rho, 'time':reported_time, 'gamma':gamma}    # open file, pickle and dump data, close file    # output = open(outfile, 'wb')    #    # pickle.dump(time_step_output, output)    #    # output.close()    return time_step_outputdef sedov_main(geom_in, omega_in, time_in, blast_energy, gamma_in, outfile, position_hi=10 ,number_steps=44000,               rho_0 = 1.225E0, plot_loc='./', save_as_pdf = False, show_plots = False):##Explicitly set variables##Standard Cases##Spherical constant density should reach r=1 at t=1                nstep = number_steps                eblast = blast_energy                gv.xgeom = geom_in                gv.omega = omega_in                location = plot_loc                save_as_pdf = save_as_pdf                show_plots = show_plots#outputfile = ??????##input parameters                time = time_in                rho0 = rho_0                vel0 = 0.0E0                ener0 = 0.0E0                pres0 = 0.0E0                # cs0 = 342.3E0                cs0 = 0                gv.gamma = gamma_in##number of grid points, spatial domain, spatial stepsize.##to match hydrocode output, use the mid-sell points.#zpos = array of spatial points                zlo = 0.0E0                zhi = position_hi                zstep = (zhi - zlo)/float(nstep)                zpos = np.arange(zlo + zstep, zhi + zstep, zstep)                                # den, vel, pres, enertot, enertherm, enerkin, mach, zpos,discrete_radius, discrete_velo, discrete_pres, discrete_rho,\                # discrete_energ  = sed_1d(time, nstep, zpos, eblast, rho0, vel0, ener0, pres0, cs0, gv)# this is without the mach number                den, vel, pres, enertot, enertherm, enerkin, zpos,discrete_radius, discrete_velo, discrete_pres, discrete_rho,\                discrete_energ, eval1, eval2, alpha, eblast  = sed_1d(time, nstep, zpos, eblast, rho0, vel0, ener0, pres0, cs0, gv)#create final dictionary to pickle###dictionary is a flexible array                # single_time_output = {'density': den, 'velocity': vel, 'pressure': pres,                #                #                       'total_energy': enertot, 'thermal_energy': enertherm,                #                #                       'kinetic_energy': enerkin, 'mach': mach, 'position': zpos,                #                #                       'disc_r': discrete_radius, 'disc_u': discrete_velo,                #                #                       'disc_p': discrete_pres, 'disc_rho': discrete_rho,                #                #                       'disc_e': discrete_energ, 'j1':eval1, 'j2':eval2, 'alpha':alpha, 'eblast': eblast}}#without mach number                single_time_output = {'density': den, 'velocity': vel, 'pressure': pres,                                      'total_energy': enertot, 'thermal_energy': enertherm,                                      'kinetic_energy': enerkin, 'position': zpos,                                      'disc_r': discrete_radius, 'disc_u': discrete_velo,                                      'disc_p': discrete_pres, 'disc_rho': discrete_rho,                                      'disc_e': discrete_energ, 'j1':eval1, 'j2':eval2, 'alpha':alpha, 'eblast': eblast}                                      #open file, pickle and dump data, close file                                                      output = open(outfile, 'wb')                pickle.dump(single_time_output, output)                output.close()#plot outputs vss position#zmax controls the maximum of the x-axis on the graphs.                zmax = 1.5 * gv.r2                if show_plots:                    plt.figure()                    plt.plot(zpos, den)                    plt.axis([0,  zmax, 0, max(den)])                    plt.title('Density vs. Position')                    plt.ylabel('Density (g/cm^3)')                    plt.xlabel('Position (Cm)')                    if save_as_pdf:                        plt.savefig(location + '/Density vs. Position' + '.pdf')                    else:                        plt.show()                    plt.close()                    plt.figure()                    plt.plot(zpos, vel)                    plt.axis([0, zmax, 0, max(vel)])                    plt.title('Velocity vs. Position')                    plt.ylabel('Velocity (Cm/s)')                    plt.xlabel('Position (Cm)')                    if save_as_pdf:                        plt.savefig(location + '/Velocity vs. Position' + '.pdf')                    else:                        plt.show()                    plt.close()                    plt.figure()                    plt.plot(zpos, pres)                    plt.axis([0,  zmax, 0, max(pres)])                    plt.title('Pressure vs. Position')                    plt.ylabel('Pressure (erg.Cm^3)')                    plt.xlabel('Position (Cm)')                    if save_as_pdf:                        plt.savefig(location + '/Pressure vs. Position' + '.pdf')                    else:                        plt.show()                    plt.close()                    plt.figure()                    plt.plot(zpos, enertot)                    plt.axis([0,  zmax, 0, max(enertot)])                    plt.title('Total Energy vs. Position')                    plt.ylabel('Energy (erg)')                    plt.xlabel('Position (Cm)')                    if save_as_pdf:                        plt.savefig(location + '/Total Energy vs. Position' + '.pdf')                    else:                        plt.show()                    plt.close()                    plt.figure()                    plt.plot(zpos, enertherm)                    plt.axis([0,  zmax, 0, max(enertherm)])                    plt.title('Thermal Energy vs. Position')                    plt.ylabel('Energy (erg)')                    plt.xlabel('Position (Cm)')                    if save_as_pdf:                        plt.savefig(location + '/Thermal Energy vs. Position' + '.pdf')                    else:                        plt.show()                    plt.figure()                    plt.plot(zpos, enerkin)                    plt.axis([0,  zmax, 0, max(enerkin)])                    plt.title('Kinetic Energy vs. Position')                    plt.ylabel('Energy (erg)')                    plt.xlabel('Position (Cm)')                    if save_as_pdf:                        plt.savefig(location + '/Kinetic Energy vs. Position' + '.pdf')                    else:                        plt.show()                    plt.close()#without mach number                # plt.plot(zpos, mach)                #                # plt.axis([0,  zmax, 0, max(mach)])                #                # plt.title('Mach Number vs. Position')                #                # plt.ylabel('Mach Number')                #                # plt.xlabel('Position (Cm)')                #                # plt.show()                #final graph plots scaled density, pressure and velocity one one plot.                    plt.figure()                    plt.plot(zpos, den/max(den), 'b', label = 'Density')                    plt.plot(zpos, pres/max(pres), 'g', label = 'Pressure')                    plt.plot(zpos, vel/max(vel), 'r', label = 'Velocity')                    plt.axis([0,  zmax, 0, 1])                    plt.legend(loc = 'upper left')                    plt.title('Scaled Density, Pressure, and Velocity')                    plt.ylabel('Scaled Value (x/max(x))')                    plt.xlabel('Position (Cm)')                    if save_as_pdf:                        plt.savefig(location + '/Scaled Density, Pressure, and Velocity' + '.pdf')                    else:                        plt.show()                    plt.close()              #define function to produce results at different points in time instead of sedov_1ddef sedov_main_time(geom_in, omega_in, time_initial, time_final, time_steps, blast_energy, gamma_in, outfile,                    position_hi=10 ,number_steps=44000, rho_0=1.225E0):##Explicitly set variables##Standard Cases##Spherical constant density should reach r=1 at t=1                nstep = number_steps                eblast = blast_energy                gv.xgeom = geom_in                gv.omega = omega_in#outputfile = ??????##input parameters                rho0 = rho_0                vel0 = 0.0E0                ener0 = 0.0E0                pres0 = 0.0E0                # cs0 = 342.3E0                cs0 = 0                gv.gamma = gamma_in##number of grid points, spatial domain, spatial stepsize.##to match hydrocode output, use the mid-sell points.#zpos = array of spatial points                zlo = 0.0E0                zhi = position_hi                zstep = (zhi - zlo)/float(nstep)                zposition = np.arange(zlo + zstep, zhi + zstep, zstep)                                             # den_time, vel_time, pres_time, enertot_time, enertherm_time, enerkin_time, mach_time, zpos_time, time,\                # discrete_radius, discrete_velo, discrete_pres, discrete_rho,\                # discrete_energ = sed_1d_time(time_initial, time_final, time_steps, nstep, zposition, eblast, rho0, vel0, ener0, pres0, cs0, gv)#without mach number                den_time, vel_time, pres_time, enertot_time, enertherm_time, enerkin_time, zpos_time, time, \                discrete_radius, discrete_velo, discrete_pres, discrete_rho, \                eblast_ = sed_1d_time(time_initial, time_final, time_steps, nstep, zposition, eblast, rho0, vel0, ener0, pres0,                             cs0, gv)#create final dictionary to pickle###dictionary is flexible array                # time_step_output = {'density': den_time, 'velocity': vel_time, 'pressure': pres_time,                #                #                       'total_energy': enertot_time, 'thermal_energy': enertherm_time,                #                #                       'kinetic_energy': enerkin_time, 'mach': mach_time,                #                #                       'position': zpos_time, 'time': time, 'disc_r':discrete_radius, 'disc_u': discrete_velo,                #                #                     'disc_p':discrete_pres, 'disc_rho':discrete_rho, 'disc_e':discrete_energ}#without mach number                time_step_output = {'density': den_time, 'velocity': vel_time, 'pressure': pres_time,                                      'total_energy': enertot_time, 'thermal_energy': enertherm_time,                                      'kinetic_energy': enerkin_time,                                      'position': zpos_time, 'time': time, 'disc_r':discrete_radius, 'disc_u': discrete_velo,                                    'disc_p':discrete_pres, 'disc_rho':discrete_rho, 'disc_e':eblast}                                      #open file, pickle and dump data, close file                                                      output = open(outfile, 'wb')                pickle.dump(time_step_output, output)                output.close()                                      # #zmax controls the maximum of the x-axis on the graphs.##                 zmax = 1.1 * gv.r2# # figures' sizes##                 xsize = 5#                 ysize = 4# # floating points#                 fpoints = 3#                 float_string = 't= %.'+str(fpoints)+'f'# # for loops graph a plot for each time step in the final soulution##                 if show_plots:##                     plt.figure(figsize=(xsize,ysize))##                     for i in range(0, time_steps):##                         plt.plot(zpos_time[i], den_time[i], label = float_string % time[i])##                     plt.xlim([0, zmax])##                     plt.title('Density vs. Position')##                     plt.ylabel('Density (g/Cm^3)')##                     plt.xlabel('Position (Cm)')##                     plt.legend(bbox_to_anchor=(1.05, 1), loc=2, borderaxespad=0., fontsize = 10)##                     plt.tight_layout()##                     if save_as_pdf:#                         plt.savefig(location + '/Density vs. Position'+'.pdf')#                     else:#                         plt.show()##                     plt.close()##                     plt.figure(figsize=(xsize,ysize))##                     for i in range(0, time_steps):##                         plt.plot(zpos_time[i], vel_time[i], label = float_string % time[i])##                     plt.xlim([0, zmax])##                     plt.title('Velocity vs. Position')##                     plt.ylabel('Velocity (Cm/s)')##                     plt.xlabel('Position (Cm)')##                     plt.legend(bbox_to_anchor=(1.05, 1), loc=2, borderaxespad=0., fontsize = 10)##                     plt.tight_layout()##                     if save_as_pdf:#                         plt.savefig(location + '/Velocity vs. Position' + '.pdf')##                     else:#                         plt.show()##                     plt.close()##                     plt.figure(figsize=(xsize,ysize))##                     for i in range(0, time_steps):##                         plt.plot(zpos_time[i], pres_time[i], label = float_string % time[i])##                     plt.xlim([0, zmax])##                     plt.title('Pressure vs. Position')##                     plt.ylabel('Pressure (erg.Cm^3)')##                     plt.xlabel('Position (Cm)')##                     plt.legend(bbox_to_anchor=(1.05, 1), loc=2, borderaxespad=0., fontsize = 10)##                     plt.tight_layout()##                     if save_as_pdf:#                          plt.savefig(location + '/Pressure vs. Position' + '.pdf')##                     else:#                         plt.show()##                     plt.close()##                     plt.figure(figsize=(xsize,ysize))##                     for i in range(0, time_steps):##                         plt.plot(zpos_time[i], enertot_time[i], label = float_string % time[i])##                     plt.xlim([0, zmax])##                     plt.title('Total Energy vs. Position')##                     plt.ylabel('Energy (erg)')##                     plt.xlabel('Position (Cm)')##                     plt.legend(bbox_to_anchor=(1.05, 1), loc=2, borderaxespad=0., fontsize = 10)##                     plt.tight_layout()##                     if save_as_pdf:#                         plt.savefig(location + '/Total Energy vs. Position' + '.pdf')##                     else:#                         plt.show()##                     plt.close()##                     plt.figure(figsize=(xsize,ysize))##                     for i in range(0, time_steps):##                         plt.plot(zpos_time[i], enertherm_time[i], label = float_string % time[i])##                     plt.xlim([0, zmax])##                     plt.title('Thermal Energy vs. Position')##                     plt.ylabel('Energy (erg)')##                     plt.xlabel('Position (Cm)')##                     plt.legend(bbox_to_anchor=(1.05, 1), loc=2, borderaxespad=0., fontsize = 10)##                     plt.tight_layout()##                     if save_as_pdf:#                         plt.savefig(location + '/Thermal Energy vs. Position' + '.pdf')##                     else:#                         plt.show()##                     plt.close()##                     plt.figure(figsize=(xsize,ysize))##                     for i in range(0, time_steps):##                         plt.plot(zpos_time[i], enerkin_time[i], label = float_string % time[i])##                     plt.xlim([0, zmax])##                     plt.title('Kinetic Energy vs. Position')##                     plt.ylabel('Energy (erg)')##                     plt.xlabel('Position (Cm)')##                     plt.legend(bbox_to_anchor=(1.05, 1), loc=2, borderaxespad=0., fontsize = 10)##                     plt.tight_layout()##                     if save_as_pdf:#                         plt.savefig(location + '/Kinetic Energy vs. Position' + '.pdf')#                     else:#                         plt.show()##                     plt.close()##                     plt.figure(figsize=(xsize,ysize))##     #without mach number plot#                     # for i in range(0, time_steps):#                     ##                     #     plt.plot(zpos_time[i], mach_time[i], label = float_string % time[i])#                     ##                     # plt.xlim([0, zmax])#                     ##                     # plt.title('Mach Number vs. Position')#                     ##                     # plt.ylabel('Mach Number')#                     ##                     # plt.xlabel('Position (Cm)')#                     ##                     # plt.legend(bbox_to_anchor=(1.05, 1), loc=2, borderaxespad=0., fontsize = 10)#                     ##                     # plt.tight_layout()#                     ##                     # if save_as_pdf:#                     #     plt.savefig(location + '/Mach Number vs. Position' + '.pdf')#                     # if show_plots:#                     #     plt.show()##                     plt.close()###     # storing the position, velocity, energy, pressure, rho at every time###     #final graph plots scaled density, pressure and velocity one one plot.##     #                plt.plot(zpos, den/max(den), 'b', label = 'Density')##     #                plt.plot(zpos, pres/max(pres), 'g', label = 'Pressure')##     #                plt.plot(zpos, vel/max(vel), 'r', label = 'Velocity')##     #                plt.axis([0,  zmax, 0, 1])##     #                plt.legend(loc = 'upper left')##     #                plt.title('Scaled Density, Pressure, and Velocity')##     #                plt.ylabel('Scaled Value (x/max(x))')##     #                plt.xlabel('Position (m)')##     #                plt.show()##                 # plt.close()#